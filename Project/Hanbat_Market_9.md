# 주요 키워드
- MongoDB: NoSQL로 데이터가 json 형태로 되어있기 때문에 수정이 매우 적어 방대한 양의 데이터를 저장하는데 용이하다. 또한 RDBMS처럼 데이터 조회 시 join으로 여러 테이블을 조회할 것도 아니므로 성능면에서도 채팅에서는 우위를 보인다.

- Netty: A사용자가 서버에 요청을하고 서버가 DB를 조회하고 응답받는데 3초가 걸린다고 가정해보자. 그 사이에 새로운 B 사용자가 서버에 요청을 보낸다면 A의 DB 응답을 기다리는동안 B 사용자의 요청을 처리해준다. 그리고 3초가 지나면 A사용자의 요청의 DB 응답을 응답해준다. 즉 기다리는 시간 동안 할 수 있는 일들을 찾아서 해준다
**즉 비동기 서버는 스레드 하나로 돌리는데 대신 놀고 있는 시간이 없고 따라서 무척 빠르다.**
만약 비동기 서버를 사용할거면 db도 비동기여야 한다. 데이터베이스가 동기이면 아무리 서버에서 여러 요청을 받을 수 있다 해도 db가 동기이면 요청을 하나만 처리할 수 있기 때문이다. Mongo를 선택한 또 다른 이유는 여기에 있다.

- Flux: 서버가 클라이언트에게 응답을 스트림으로 흘려보낸다

- @Tailable: 처음 했던 요청이 find라면 MongoDB에서 데이터가 save 될 때마다 계속 find 한다.

- SSE: 만약 HTTP 프로토콜이라면 요청을 해서 첫 응답을 받으면 연결이 종료될 것이다. 하지만 SSE 프로토콜을 사용해서 첫 요청 이후 계속된 응답을 FLUX로 받는다.

### 구현 방식

우리는 이 방식을 이용해 채팅을 구현할 것이다.

순서로 구현방식을 설명하지만 비동기이기 때문에 이 모든과정이 거의 동시에 일어난다고 생각하면 된다.

1. 클라이언트1이 HTTP로 채팅을 보낸다 -> MongoDB에 저장
2. SSE로 DB에 채팅을 비동기 조회한다. -> 서버는 Flux로 바로 클라이언트에게 응답
3. 클라이언트2가 또 HTTP로 채팅을 보낸다 -> MongoDB에 저장
4. SSE로 요청이 되어 있기에 아직 응답이 열려있다(sub) @Tailabe로 인해 또 저장된 데이터가 조회된다 -> 서버는 Flux로 바로 클라이언트에게 응답
- 위 같은 방법으로 실시간 채팅이 구현이 된다.
우리의 프로젝트는 규모가 작기 때문에 MongoDB를 사용해보는 경험도 해보자는 이유로 이 방식을 도입했다.
