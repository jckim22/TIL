![](https://velog.velcdn.com/images/jckim22/post/fda7aa66-52e1-446c-9068-d1885c614da3/image.png)




# MVC 패턴이란?

모델-뷰-컨트롤러(Model–View–Controller, MVC)는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다.
이 패턴을 성공적으로 사용하면, 사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.
출처 - 위키피디아

MVC pattern 은 프로그래밍을 할 때 전체적인 구조에 관련된 여러 디자인 패턴 중 하나이며, 도메인(비즈니스)로직과 UI로직을 분리하여 유지보수를 독립적으로 수행할 수 있게 하는 장점이 있다.


# MVC 패턴 - M ( Model ,  domain ) 
Model 이란 프로그램이 작업하는 세계관의 요소들을 개념적으로 정의한 것이라고 볼 수 있다.

데이터를 가지고 있는 객체 , 테이터가 바뀌었을 때 컨트롤러의 데이터를 업데이트 하는 로직도 포함한다.

 

프로그램이 목표하는 작업을 원활하게 수행하기 위해 필요한 물리적 개체, 규칙, 작업 등의 요소들을 구분되는 역할로서

정의해놓은 것이 Model이 된다.

 

# Model - DAO
Data Access Object

 

실질적으로 DB의 data에 접근하는 트랜잭션 객체를 말한다. 일종의 객체라는 것을 잊지말자!

DB를 사용해서 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 Object

domain logic(비즈니스 로직이나 DB와 관련없는 코드들) 으로부터 persistence mechanism을 숨기기 위해 사용한다.

 - 적절히 디자인을 하면 모든 domain logic을 바꾸는 대신에 DAO만 바꾸기만 하면 되는 것!

 - persistence layer(퍼시스턴트 계층) : Database에 data를 CRUD(Create,  Read, Update, Delete) 하는 계층.

 

 

# Model - DTO
Data Transfer Object , VO(Value Object) 로 표현하기도 한다.

 

계층간의 데이터 교환을 위한 JAVA Beans를 말한다. 여기서 말하는 계층은 컨트롤러, 뷰, 비즈니스 계층, 퍼시스턴트 계층을 말하며 

각 계층 간의 데이터 교환을 위한 객체를 DTO 또는 VO 라고 부른다.

( Database에서 Data를 얻어 Service나 Controller 등으로 보낼 때 사용하는 객체라고 생각)

* VO 와 DTO는 동일한 개념이지만 VO 는 read only 속성을 가진다.

 

일반적인 DTO 는 로직을 가지고 있지 않다.

순수한 데이터 객체이며 속성과 그 속성에 접근하기 위한 getter, setter 메소드만 가진 클래스를 말한다.

여기에 추가적으로 to String() , equals() 등의 Object 클래스 메소드를 작성할 수 있다.

 ## DTO,DAO ?
 
 DTO, DAO를 이렇게 말로만 들으면 잘 이해가 되지 않을 수 있다.
 블로그를 돌아다니며 아래와 같은 기본적인 DTO, DAO를 이해하기 쉬운 코드가 있었다.

 ```java
		CompanyDao dao = new CompanyDao();
		
		
		CompanyDto dto1 = new CompanyDto();
		dto1.setEname("이00");
		dto1.setJob("개발");
		
		boolean isSuccess = dao.insert(dto1);
		if(isSuccess) {
			System.out.println("삽입 성공");
		}else {
			System.out.println("삽입 실패");
		}
		
		
		CompanyDto dto2 = new CompanyDto();
		dto2.setEmpno(1);
		dto2.setEname("최00");
		dto2.setJob("전산");
		
		boolean isSuccess2 = dao.update(dto2);
		if(isSuccess2) {
			System.out.println("갱신 성공");
		}else {
			System.out.println("갱신 실패");
		}
```
>위처럼 Setter로 DTO에서는 DAO에 줄 객체를 세팅한다.
허나 이 객체가 전달되는 도중 훼손되는 것을 막기 위해 생성자로 세팅하는 것이 더 바람직하다.
이후 DAO에서 객체를 Insert하거나 Update하는 로직을 수행한다.
DAO에서는 실질적으로 DB의 data에 접근하는 트랜잭션 '객체'이다.



# Model - Domain ?
그래서 Domain, Business 로직은 뭐고 Service로직은 뭘까?

##  모바일 송금의 예시
예를 들어서, 흔한 모바일 송금 앱이 있다고 해보자.

송금 기능을 담당하는 코드가 있다.
이 코드를 자세히 뜯어보면 다음과 같은 일을 하는 코드로 이뤄져있다.

계좌 잔액이 충분한지 확인한다.
유효하다면 송금 버튼을 활성화하고, 유효하지 않다면 에러 메시지를 띄운다.
사용자의 멤버십 등급에 맞춰서 송금 수수료를 계산한다.
송금 수수료를 결제하도록 외부 결제 서비스에 요청한다.
사용자의 잔액을 감소시킨다.
사용자의 잔액을 DB에 저장한다.
이 코드들을 구분할 때, 해당 소프트웨어가 '송금'이라는 현실 문제에 대한 의사결정을 하는가를 생각해보자.

어떤 것이 도메인 로직이고, 어떤 것이 서비스 로직일까?

도메인 로직에 해당하는 것은 다음과 같다.
이 코드들은 '송금'에 대한 의사결정을 담당하고 있다.

계좌 잔액이 충분한지 확인 -> 송금이 가능한지에 대한 의사결정
송금 수수료를 계산 -> 송금에 드는 비용을 정책에 따라서 결정
사용자의 잔액을 감소시킨다 -> 송금이라는 서비스를 수행
어플리케이션 서비스 로직에 해당하는 것은 다음과 같다.
이 코드들은 도메인 로직이 의사결정을 할 수 있도록 입력을 제공하며, 결과를 외부 서비스/DB/UI에 업데이트하는 역할을 맡는다.

유효하지 않으면 에러 메시지를 띄운다 -> UI
송금 수수료를 결제하도록 외부 결제 서비스에 요청한다. -> 외부 서비스와의 네트워킹
잔액을 DB에 저장한다. -> Persistence
>만약 어떤 코드가 명확하게 도메인 로직인지 아닌지 애매하다면, 해당 코드가 하는 일을 쪼개야 한다는 신호다. 도메인 로직이 분명한 부분과 서비스 로직이 섞여 있을 수도 있다.

현재 가지고 있는 원화가 미국 달러로 얼마인지 보여주는 함수가 있다고 해보자.

이 함수 하나만 가지고 생각하면 도메인 로직인지 아닌지 애매하다.
하지만 함수를 분리하고 코드를 쪼개보면 좀 더 명확해진다.

미국 달러 환율을 얼마로 할 것인가. 계산 공식은 얼마로 할 것인지 결정하는 코드. -> 도메인 로직
단위와 화폐 포맷을 바꿔서 UI에 업데이트를 하는 코드. -> 어플리케이션 서비스 로직

 


# MVC 패턴 - V (View)
사용자가 보는 화면에 입출력 과정 및 결과를 보여주기 위한 역할을 한다.

입출력의 순서나 데이터 양식은 컨트롤러에 종속되어 결정되고, 도메인 모델의 상태를 변환하거나 받아서 렌더링 하는 역할을 한다.

 

* view를 구현할 때 주의해야할 점은 도메인 로직의 어떤 것도 알고 있으면 안된다는 것이다.

절대적으로 객체를 전달받아 상태를 바로 출력하는 역할만을 담당해야 한다. 

그렇기 때문에 view에서는 도메인 객체의 상태를 따로 저장하고 관리하는 클래스 변수 혹은 인스턴스 변수가 있을 필요가 없다.

 

 

 

 

# MVC 패턴 - C ( Controller )
controller 는 model과 view를 연결 시켜주는 다리 역할을 함과 동시에 도메인 객체들의 조합을 통해

프로그램의 작동 순서나 방식을 제어한다.

 

controller는 view와 model이 각각 어떤 역할을 하는지 알고 있어야 한다.



 

> Service에서 DB에 저장을 하려면 View->Controller에서 DATA를 받아서 DAO를 호출해야한다.

 
