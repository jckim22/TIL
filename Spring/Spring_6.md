# DATABASE TOOL

공부용으로 적합한 H2를 사용하겠다.
웹에서 실행되기 때문에 매우 가볍다.

```sql
create table member
(
    id   bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);

```

위처럼 테이블을 등록하고

```sql
insert into member values('spring')
insert into member values('spring2')
```

위처럼 데이터를 넣어보고 조회하면 아래처럼 잘 저장된 것을 볼 수 있다.

![](https://velog.velcdn.com/images/jckim22/post/744fc911-12b4-4f1f-8d2a-4e04cc26c8eb/image.png)


# 순수 JDBC

20년 전 쯤 사용하던 JDBC 기술을 직접 사용해보자


### build.gradle
```java
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	runtimeOnly 'com.h2database:h2'
```

jdbc와 h2를 끌고온다.

### application.properties

```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```
local H2 서버에 설정을 입력한다.

### Interface 구현

```java
public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;

    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql,
                    Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName());
            pstmt.executeUpdate();
            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();

            List<Member> members = new ArrayList<>();
            while (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }

            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }

    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);

    }
}
```

>문법은 옛날 기술이기 때문에 중요하지 않다.
다만 DataSource에서 Connection을 갖고 온다는 것만 알고 있자.

이렇게 MemberRepository 인터페이스의 새로운 구현체를 완성했다.


이제 전에 작성했던 SpringConfig를 수정해보자

### SpringConfig

```java
@Configuration
public class SpringConfig {

    private DataSource dataSource;

    @Autowired
    public SpringConfig(DataSource dataSource){
        this.dataSource = dataSource;
    }

    @Bean
    public MemberService memberService(){
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository(){
//        return new MemoryMemberRepository();
        return new JdbcMemberRepository(dataSource);
    }
}
```
>Spring에서 DataSource는 스프링 빈으로 등록해놨기 때문에 DI를 할 수 있다.

이전에 생성했던 MemoryMemberRepository를 새로운 구현체로 대체한다.
그리고 실행해보자

![](https://velog.velcdn.com/images/jckim22/post/c4001534-8052-4e37-b886-46603d90bf68/image.png)
위처럼 회원정보를 등록하면
![](https://velog.velcdn.com/images/jckim22/post/dfa4ca2c-e9b5-4ef6-ab77-b76a1e3a2ffa/image.png)
members에 이전에 쿼리로 직접 넣었던 데이터와 함께 조회가 된다.
![](https://velog.velcdn.com/images/jckim22/post/d5376c81-42a9-4596-9f8a-6e4c16932952/image.png)
그리고 직접 데이터베이스에서 조회를 해보아도 똑같다.

이제 휘발성 Memory가 아닌 DataBase 서버에 저장을 할 수 있게 되었다.


### Spring을 사용하는 이유

지금까지 구조를 보면 아래와 같다.
MemberService는 MemberRepository를 의존하고 있고 그것에 구현체는 메모리와 JDBC 2개가 있다.
![](https://velog.velcdn.com/images/jckim22/post/9cec6b65-b555-47d5-aca3-5a3d00352817/image.png)

하지만 아래처럼 우리는 다른 어떤 코드를 수정, 변경하지도 않고 config만 수정해서 새로운 확장 구현체를 사용하게 되었다.
![](https://velog.velcdn.com/images/jckim22/post/91503e90-7068-4d39-9ea9-ed1ac10b6fad/image.png)

이렇게 개방-폐쇄 원칙을 지킬 수 있게 되었다.

>개방-폐쇄 원칙(OCP, Open-Closed Principle) 확장에는 열려있고, 수정, 변경에는 닫혀있다.


스프링의 DI (Dependencies Injection)을 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경할 수 있다.

회원을 등록하고 DB에 결과가 잘 입력되는지 확인하자.
데이터를 DB에 저장하므로 스프링 서버를 다시 실행해도 데이터가 안전하게 저장된다.

# JDBC_TEMPLATE

JDBC를 순수하게 구현하고 있자니 중복된 코드들이 너무 많았다.

```java
public class JdbcTemplateMemberRepository implements MemberRepository {
    private final JdbcTemplate jdbcTemplate;

    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());
        Number key = jdbcInsert.executeAndReturnKey(new
                MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ? ", memberRowMapper(), name);
        return result.stream().findAny();
    }

    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
}
```

위는 JDBC Template로 작성한 구현체이다.
순수 JDBC를 활용할 때보다 중복된 코드가 줄었다.
RowMapper를 통해서 매핑을 해주기 때문이다.
